<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div class="新增关键字">
        ## let --定义变量
        ## 特点：let关键字定义的变量更加严格， 拥有块级作用域，不可用提升，不可用重复定义
        ## const --定义常量
        ## 特点：拥有块级作用域、不可以重复定义、没有声明提升、不可以作为循环变量、如果常量的值是一个引用类型，则可以添加属性、删除属性、但是不可以修改常量的地址




        字符串方法 ：
        str.startsWith （str , num） --判定字符串是否是以某一个字符串开头

        str：判定的开头字符串
        num：偏移数字下标
        返回值： 布尔值

        str.endsWith(str1 , num) --判定字符串是否是以另外一个字符串结尾

        str1：结尾字符串
        num : 截取位置， 该位置是源字符串的下标， 表示从0开始 结尾的位置
        返回值： 布尔值

        str2.includes(str , num) ---判定str2中是否包含str

        str： 被包含的字符串
        num ：截取的位置
        返回值： 布尔值

        str.repeat(num) ：用于重复字符串num次

        num： 重复次数
        返回值： str重复了num次之后的新字符串


        定义多行字符串 : ` ` ---用于前端模板

        <!-- ---------------------------------------------------------------------------- -->
        数组方法 ：
        Array.of() - - 用于创建数组 -参数：数组成员

        Array.from() ---用于将类数组对象转换成对象 -参数：类数组对象

        arr.find(handler) ---用于模糊查询数组中的成员
        handler ：处理函数 函数有三个参数 该函数返回布尔值
        第一个是数组成员
        第二个是成员下标
        第三个是原数组
        返回值：根据handler的返回值而定 如果handler在循环某一次的时候返回了true ，
        则find方法返回的就是该次的成员。如果都没有返回true ，则find方法返回undefined
        <!-- ---------------------------------------------------------------------------- -->
        arr.findIndex(handler) 用于查询数组的成员下标

        handler ：同find方法的handler
        返回值： 下标值
        <!-- ---------------------------------------------------------------------------- -->

        arr.copyWithin(pos , start , end) 用于将数组内部的start到end 复制一份并从POS开始替换

        POS：替换位子
        start： 复制的开始位子
        end： 复制的结束位子

        返回值：原数组 该方法会改变原数组

        对象的新特点：如果对象的属性名和属性值一致 ， 则可以忽略 value

        方括号语法可以应用在定义对象的字面量语法name中：[red +1 ]= "red1";

        定义方法时，可以省略function！ ----对象才有方法
        <!-- ---------------------------------------------------------------------------- -->
        object.assign :该方法用于复制对象的属性 ---浅复制对象属性

        object.assign(target, obj1 , obj2 ,....)

        作用：将obj1 obj2以及以后的对象的属性复制给target

        jQuery中的extend方法:
        $.extend(true , obj , obj1 , obj2 , obj3.....)
        该方法可以用于深复制， 也可用于浅复制
        ## 当第一个参数为true时，表示深复制 ， 将obj1/obj2/obj3 等对身上的属性深复制给obj
        ## 当第一个参数不是true时 ，表示浅复制
        <!-- ----------------------------------------------------------------------------。 -->
        object.is(XXX , XXX ) ： 该方法用于判定两个值是否全等
        参数： 两个比较值 ， 返回值布尔值
        <!-- 该方法和普通的大为相反 -->
        <!-- ---------------------------------------------------------------------------- -->


    </div>
    <div class="代理类">
        proxy类： 用于生成某一个对象的代理对象
        var proxy = new Proxy(obj , {
        get: function(target， prop， proxy){
        <!-- get没有返回值 -->
        <!-- target：目标对象 -->
        <!-- prop：属性 -->

        },
        set:function(target， prop，value， proxy){

        }
        })
    </div>
    <div class="数学方法">
        object.is 该方法用于判定两个值是否全等
        参数：是两个比较值 ，返回布尔值

        Is.NaN： 在JS中有两个：---Nan--
            一个是window.isNaN  用于判定一个值是否是全等  
            一个是ES6增加的Number.isNaN 用于判定一个数字是否是NaN

        isFinite ： 在JS中有两个： --有限的--
            一个是window.isFinite 用于判定一个值是否是有限的---判断条件是是有限的
            一个是ES6增加的Number.isFinite 用于判定一个值是否是isFinite  ---有限的
        isInteger : 
            该方法只有一个ES6新增的在Number身上 ：
        用于判定一个数值是否是整数




        数学方法：
        Math.cbrt：计算一个数的立方根。
        Math.fround：返回一个数的单精度浮点数形式。
        Math.hypot：返回所有参数的平方和的平方根。
        Math.expm1(x)：返回ex - 1。
        Math.log1p(x)：返回1 + x的自然对数。如果x小于-1，返回NaN。
        Math.log10(x)：返回以10为底的x的对数。如果x小于0，则返回NaN。
        Math.log2(x)：返回以2为底的x的对数。如果x小于0，则返回NaN。
        三角函数方法
        Math.sinh(x) 返回x的双曲正弦
        Math.cosh(x) 返回x的双曲余弦
        Math.tanh(x) 返回x的双曲正切
        Math.asinh(x) 返回x的反双曲正弦
        Math.acosh(x) 返回x的反双曲余弦
        Math.atanh(x) 返回x的反双曲正切
        Math.sign 获取数字的标志




    </div>
    <div class="Symbol">
        在ES6之前 ， 一共有6种数据类型：null ,undefined ,number , string ,object , boolean
        在ES6中 ，增加了一种数据类型 ： symbol 这是一种独一无二的符号
        Symbol 不是构造函数 ， 参数的作用 ： 语义
    </div>
    <div class="语法">
        ... :语法用于获取函数的剩余参数
        ... ：语法用于拆分数组

        获取剩余参数： 函数的形参列表中 ， 可以使用 ... 语法 。 用于获取剩余参数。
        ... args :

        拆分数组：
        在使用函数时 ， 如果函数需要参数 ， 并且参数都放在一个数组中， 在以前需要apply辅助 ，现在
        就可以使用 ...arr 来完成传参行为。

        <!-- ---------------------------------------------------------------------------- -->

        for ....of 循环
        该循环语句 是用于循环迭代器的。
        for --of 语法 搭配 迭代器方法 配合使用：



        // 定义数组
        var arr = "abcdefghijkl".split("");
        // 调用entries方法 该方法用于获取目标的所有成员值 但是不会直接返回 返回的是一个迭代器接口对象 我们可以通过该接口对象顺序的访问内部想要的内容
        var iterator = arr.entries();
        for(var i of iterator) {
        console.log(i)
        }
    </div>
    <div class="解构数组">
        ... 用法：
        var arr = [1,2,3,4]
        var [1,2 , ...arr1 ] = arr
        arr1 : [3,4]
    </div>
    <div class="箭头函数">
        定义语法 ：var fun = () => {}

        圆括号 ： 形参列表
        箭头： =>
        大括号 ：函数体

        注意事项：
        1：
        通过function ：关键字 定义出来的函数 ， 里面的this 是可变的 。谁调用它this 就是谁
        通过箭头函数方式 定义的函数， this 只跟定义箭头函数的作用域有关
        2：
        不可以作为构造函数使用 ---不能new
        3：
        没有arguments ---没有形参
        4：
        简写：箭头函数提供了简写规则。
        简写参数列表： 当参数只有一个时 ， 可以省略形参列表的圆括号
        简写函数体： 当函数体中只有一句代码 ， 并且还是返回值时 ， 可以省略大括号和return
        5：更改this

        箭头函数中的this： 永远都是定义该箭头函数的作用域 的this

        明白了箭头函数中的this的变化规则 就可以相应的改变通常情况下， 我们就会在箭头函数外套一个普通函数。
        再执行普通函数时 ， 改变普通函数的this 即可
        定义一个对象的方法 ： 方法里放置箭头函数








    </div>
    <div class="迭代器">
        <!-- 通过split方法 返回新数组  ---以空字符串为切割 -->
        var arr = "aaaaaaaaaaaaaa".split("");
        var iterator = arr.keys();
        var iterator = arr.values();
        var iterator = arr.entries();

        iterator.next() ---------表示调用一次
        // 调用keys方法 该方法用于获取目标的所有索引值 但是不会直接返回 返回的是一个迭代器接口对象 我们可以通过该接口对象顺序的访问内部想要的内容
        // 调用values方法 该方法用于获取目标的所有成员值 但是不会直接返回 返回的是一个迭代器接口对象 我们可以通过该接口对象顺序的访问内部想要的内容
        // value是一个对象 有两个属性 第一个是value 就是第一次迭代得到的下标 值为0 第二个属性是done 表示是否还可以继续迭代 true或者false
        // 调用entries方法 该方法用于获取目标的所有成员值 但是不会直接返回 返回的是一个迭代器接口对象 我们可以通过该接口对象顺序的访问内部想要的内容



        迭代器模式定义： 给定一种方式，能够顺序的遍历目标内部数据，但是又不暴露内部结构
        jQuery 。 underscore . es5
        $.each _.eacg arr.forEach

        ES6中 ， 实现了接口Iterator 数组实现了3个迭代器方法

    </div>
    <div class="数据结构">
        Set :是一个数组相关的数据结构
        这是一个去重数组
        var set = new Set([1, false , null , undefined , {} , function(){}])
        set里面的方法：
        clear :清除所有
        delete： 删除一项
        has： 判断是否拥有
        keys : 迭代器方法
        values : 迭代器方法
        entries : 迭代器方法
        forEach ： ES5迭代器方法

        WeakSet 是一个弱Set 。成员只能够是引用类型
        不会被计入垃圾回收机制
        var WeakSet = new WeakSet([[]])

        Map ：是一个对象相关的数据结构

        Map 可以认为是一个超对象
        普通的对象的key只能是字符串 ， Map的key可以是任意类型

        set: 用于设置成员 第一个参数是key 类型可以是任意 第二个参数是value 类型可以是任意
        get: 用于获取成员 第一个参数是key 类型可以是任意 返回值是对应的值
        clear:清空
        delete: 删除一项
        has: 判断是否存在
        keys: 获取迭代器对象
        values: 获取迭代器对象
        entries: 获取迭代器对象
        forEach: ES5的迭代器方法

        weakMap ： 这是一个弱Map 每一个键都只能是引用类型
        也不会被垃圾机制回收












    </div>
    <div class="异步编程">

        Generator 状态函数

        Generator 状态函数是一个异步编程的解决方案

        语法： function * name () {}

        在function 与函数名之间 ， 加入一个 * 它就是一个状态函数
        yield 是一个关键字 用于状态函数内， 定义一个阶段的任务

        next 方法传递参数：


        Promise
        Promise 这是一个异步编程的解决方案
        它没有改变异步代码的执行发送方式， 仅仅是将书写形式从回调形式修改为同步形式

        Promise 是一个构造函数 ， 能够监听异步代码的执行情况 。

        一个Promise 实例， 有三种状态 。 pending resolved rejected
        状态的流向一共有二种可能性 pending=> resolved pending => rejected

        一个Promise 实例能够监听这两种状态

        定义方式：
        let XXX = new Promise(function(){
        $.ajax({
        url:"/XXX",
        data:"",
        dataType:"json",
        success: function(data){
        console.log(data)
        }
        })
        })
        执行方式：接收二个参数 ： 都是函数 分别代表pending =>resolved 时执行的函数 ---成功回调
        和 pending => rejected 时的执行函数 ---失败回调

        XXX.then(()=>{

        },()=>{


        });
    </div>
    <div class="ES6语法改变">
        1:如果对象的属性名和属性值一致， 则可以忽略Value

    </div>
    <div class="复制">
        Object.assign: 该方法用于复制对象的属性
        object.assign(target , obj1 , obj2,.....)
        作用：将obj ， obj2以及之后的对象的属性复制给target


        jQuery中的extend方法：
        该方法可以用于深复制，也可以用于浅复制
        $.extend(true , obj ， obj1, obj2 ,obj3......)

        当第一个参数为true时，表示深复制 ， 将obj1 obj2等对象上的属性深复制给obj
        当第一个参数不是true时， 表示浅复制

    </div>
    <div class="类">
        ES6中的类： class关键字
    语法： class Student{

        constructor(){

        }
    }
    constructor : 是一个内置的方法 ， 等价于原来的构造按时

    定义静态方法 ： 所谓的静态方法指的是用类去调用的方法
    定义方式： 在方法名前加个 Static 

    继承： class sub extends sup{

    }

        在定义子类的时候就需要声明继续谁 ， 通过extends 关键字来声明
        还要在子类的构造函数内调用父类的构造函数并传递参数
        可继承的内容： 普通属性， 普通方法， 静态方法
        
    </div>


</body>

</html>